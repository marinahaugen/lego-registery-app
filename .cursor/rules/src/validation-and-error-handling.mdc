---
description: Frontend Error Handling Guidelines
alwaysApply: false
---
# Frontend Error Handling Guidelines

## Error Handling Stack
- **Zod** for input validation and type safety
- **React Error Boundaries** for component error catching
- **SWR** for API error handling
- **Custom error types** for domain-specific errors
- **Error reporting** for monitoring and debugging

## Input Validation with Zod

### General: 

- Always define Zod schemas for API inputs and outputs; use z.infer to derive TypeScript types.
- For optional fields, use z.optional(); for arrays and nested objects, define separate schemas.
- When evolving schemas, use Supabase's DB migration rule for column changes. 

### Schema Definition
```tsx
// schemas/user.ts
import { z } from 'zod';

export const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1, 'Name is required').max(100, 'Name too long'),
  email: z.string().email('Invalid email format'),
  age: z.number().int().positive().optional(),
  role: z.enum(['user', 'admin', 'moderator']),
});

export type User = z.infer<typeof UserSchema>;
```

### Validation in Components
```tsx
// Using safeParse for validation
function UserForm({ onSubmit }: { onSubmit: (user: User) => void }) {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    role: 'user' as const,
  });
  const [errors, setErrors] = useState<Record<string, string>>({});

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    const result = UserSchema.safeParse(formData);
    
    if (result.success) {
      setErrors({});
      onSubmit(result.data);
    } else {
      const fieldErrors: Record<string, string> = {};
      result.error.errors.forEach((error) => {
        const field = error.path.join('.');
        fieldErrors[field] = error.message;
      });
      setErrors(fieldErrors);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="text"
          value={formData.name}
          onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
          className={errors.name ? 'border-red-500' : ''}
        />
        {errors.name && <span className="text-red-500 text-sm">{errors.name}</span>}
      </div>
      {/* More form fields */}
    </form>
  );
}
```

### Custom Validation
```tsx
// Custom validation with refine
const PasswordSchema = z.string()
  .min(8, 'Password must be at least 8 characters')
  .refine(
    (password) => /[A-Z]/.test(password),
    'Password must contain at least one uppercase letter'
  )
  .refine(
    (password) => /[a-z]/.test(password),
    'Password must contain at least one lowercase letter'
  )
  .refine(
    (password) => /\d/.test(password),
    'Password must contain at least one number'
  );

const ConfirmPasswordSchema = z.object({
  password: PasswordSchema,
  confirmPassword: z.string(),
}).refine(
  (data) => data.password === data.confirmPassword,
  {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  }
);
```

## React Error Boundaries

### Basic Error Boundary
```tsx
// ErrorBoundary.tsx
import React from 'react';

interface Props {
  children: React.ReactNode;
  fallback?: React.ComponentType<{ error: Error; resetError: () => void }>;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // Report error to monitoring service
    this.reportError(error, errorInfo);
  }

  resetError = () => {
    this.setState({ hasError: false, error: null });
  };

  private reportError(error: Error, errorInfo: React.ErrorInfo) {
    // Send to error reporting service
    // Example: Sentry, LogRocket, etc.
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return (
        <FallbackComponent 
          error={this.state.error!} 
          resetError={this.resetError} 
        />
      );
    }

    return this.props.children;
  }
}

// Default fallback component
function DefaultErrorFallback({ error, resetError }: { error: Error; resetError: () => void }) {
  return (
    <div className="p-4 bg-red-50 border border-red-200 rounded-md">
      <h2 className="text-lg font-semibold text-red-800">Something went wrong</h2>
      <p className="text-red-600 mt-2">{error.message}</p>
      <button
        onClick={resetError}
        className="mt-4 px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
      >
        Try again
      </button>
    </div>
  );
}
```

### Feature-Specific Error Boundaries
```tsx
// UserProfileErrorBoundary.tsx
function UserProfileErrorFallback({ error, resetError }: { error: Error; resetError: () => void }) {
  return (
    <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-md">
      <h3 className="text-lg font-semibold text-yellow-800">Profile Loading Error</h3>
      <p className="text-yellow-600 mt-2">
        Unable to load user profile. This might be a temporary issue.
      </p>
      <button
        onClick={resetError}
        className="mt-4 px-4 py-2 bg-yellow-600 text-white rounded-md hover:bg-yellow-700"
      >
        Retry
      </button>
    </div>
  );
}

// Usage
<ErrorBoundary fallback={UserProfileErrorFallback}>
  <UserProfile userId={userId} />
</ErrorBoundary>
```

## API Error Handling

### SWR Error Handling
```tsx
// Custom error handling with SWR
function UserProfile({ userId }: { userId: string }) {
  const { data: user, error, isLoading, mutate } = useSWR(
    `/api/users/${userId}`,
    fetcher,
    {
      onError: (error) => {
        console.error('Failed to fetch user:', error);
        // Report to monitoring service
      },
      errorRetryCount: 3,
      errorRetryInterval: 1000,
    }
  );

  if (isLoading) return <div>Loading...</div>;
  
  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded-md">
        <h3 className="text-lg font-semibold text-red-800">Failed to load profile</h3>
        <p className="text-red-600 mt-2">
          {error.message || 'An unexpected error occurred'}
        </p>
        <button
          onClick={() => mutate()}
          className="mt-4 px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
        >
          Retry
        </button>
      </div>
    );
  }

  if (!user) return <div>No user found</div>;

  return <div>{user.name}</div>;
}
```

### Custom Fetcher with Error Handling
```tsx
// lib/fetcher.ts
export const fetcher = async (url: string) => {
  const response = await fetch(url);
  
  if (!response.ok) {
    const error = new Error(`HTTP error! status: ${response.status}`);
    error.name = 'HttpError';
    error.status = response.status;
    
    // Try to get error details from response
    try {
      const errorData = await response.json();
      error.message = errorData.message || error.message;
    } catch {
      // If response is not JSON, use default message
    }
    
    throw error;
  }
  
  return response.json();
};

// Usage with error handling
function useUser(userId: string) {
  return useSWR(
    userId ? `/api/users/${userId}` : null,
    fetcher,
    {
      onError: (error) => {
        if (error.name === 'HttpError' && error.status === 404) {
          // Handle not found
        } else if (error.status === 401) {
          // Handle unauthorized
        } else {
          // Handle other errors
        }
      }
    }
  );
}
```

## Custom Error Types

### Domain-Specific Errors
```tsx
// types/errors.ts
export class ValidationError extends Error {
  constructor(
    message: string,
    public field: string,
    public code: string
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class AuthenticationError extends Error {
  constructor(message: string = 'Authentication required') {
    super(message);
    this.name = 'AuthenticationError';
  }
}

export class AuthorizationError extends Error {
  constructor(message: string = 'Insufficient permissions') {
    super(message);
    this.name = 'AuthorizationError';
  }
}

export class NetworkError extends Error {
  constructor(message: string = 'Network connection failed') {
    super(message);
    this.name = 'NetworkError';
  }
}

// Usage
function handleUserAction(action: () => Promise<void>) {
  try {
    await action();
  } catch (error) {
    if (error instanceof AuthenticationError) {
      // Redirect to login
      router.push('/login');
    } else if (error instanceof AuthorizationError) {
      // Show permission denied message
      showNotification('You do not have permission to perform this action', 'error');
    } else if (error instanceof NetworkError) {
      // Show network error message
      showNotification('Network connection failed. Please check your internet connection.', 'error');
    } else {
      // Handle unknown errors
      console.error('Unexpected error:', error);
      showNotification('An unexpected error occurred. Please try again.', 'error');
    }
  }
}
```

## Error Reporting

### Error Reporting Service
```tsx
// lib/errorReporting.ts
interface ErrorReport {
  error: Error;
  context?: Record<string, any>;
  user?: {
    id: string;
    email: string;
  };
  timestamp: Date;
}

class ErrorReporter {
  private static instance: ErrorReporter;
  
  private constructor() {}
  
  static getInstance(): ErrorReporter {
    if (!ErrorReporter.instance) {
      ErrorReporter.instance = new ErrorReporter();
    }
    return ErrorReporter.instance;
  }
  
  reportError(error: Error, context?: Record<string, any>) {
    const report: ErrorReport = {
      error,
      context,
      user: this.getCurrentUser(),
      timestamp: new Date(),
    };
    
    // Send to error reporting service
    this.sendToService(report);
  }
  
  private getCurrentUser() {
    // Get current user from auth store
    return null;
  }
  
  private sendToService(report: ErrorReport) {
    // Implementation depends on service (Sentry, LogRocket, etc.)
    console.error('Error report:', report);
  }
}

export const errorReporter = ErrorReporter.getInstance();
```

### Integration with Error Boundaries
```tsx
// Enhanced ErrorBoundary with reporting
export class ErrorBoundary extends React.Component<Props, State> {
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    errorReporter.reportError(error, {
      componentStack: errorInfo.componentStack,
      componentName: this.constructor.name,
    });
  }
  
  // ... rest of implementation
}
```

## Form Error Handling

### Form Validation Hook
```tsx
// hooks/useFormValidation.ts
import { useState, useCallback } from 'react';
import { z } from 'zod';

export function useFormValidation<T extends z.ZodType>(schema: T) {
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isValidating, setIsValidating] = useState(false);

  const validate = useCallback(async (data: unknown): Promise<z.infer<T> | null> => {
    setIsValidating(true);
    setErrors({});

    try {
      const result = await schema.parseAsync(data);
      return result;
    } catch (error) {
      if (error instanceof z.ZodError) {
        const fieldErrors: Record<string, string> = {};
        error.errors.forEach((err) => {
          const field = err.path.join('.');
          fieldErrors[field] = err.message;
        });
        setErrors(fieldErrors);
      }
      return null;
    } finally {
      setIsValidating(false);
    }
  }, [schema]);

  const clearErrors = useCallback(() => {
    setErrors({});
  }, []);

  return {
    errors,
    isValidating,
    validate,
    clearErrors,
  };
}
```

## Best Practices Checklist

- [ ] Use Zod for all input validation
- [ ] Implement error boundaries for component error catching
- [ ] Handle API errors gracefully with SWR
- [ ] Create custom error types for domain-specific errors
- [ ] Report errors to monitoring service
- [ ] Provide user-friendly error messages
- [ ] Implement retry mechanisms for transient errors
- [ ] Use TypeScript for error type safety
- [ ] Test error scenarios
- [ ] Log errors for debugging
- [ ] Provide fallback UI for error states
- [ ] Handle network errors appropriately
